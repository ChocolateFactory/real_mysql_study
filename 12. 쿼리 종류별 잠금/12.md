# 쿼리 종류별 잠금
## InnoDB의 기본 잠금

### SELECT 
  * REPETABLE-READ 이하의 트랜잭션 격리 수준에서 SELECT는 아무런 잠금을 사용하지 않는다.
  * SERIALIZABLE 격리 수준에서는 모든 SELECT 쿼리에 읽기잠금을 걸고 레코드를 읽는다.
  * 읽기 모드 잠금, 쓰기모드 잠금
    ```sql
    SELECT * FROM employess WHERE emp_no=1001 LOCK IN SHARE MODE;
    SELECT * FROM employees WHERE emp_no=1001 FOR UPDATE;
    ```
    * LOCK IN SHARE MODE는 읽기잠금만 걸기 떄문에 잠금을 획득한 트랜잭션에서 변경 하려면 쓰기 잠금을 또 획득 해야한다. ( 읽기 잠금을 획득한 상태에서 다시 쓰기 잠금을 획득하는것은 데드락을 유발함.)
    * 읽은 다음 변경 까지 해야한다면 처음 부터 FOR UPDATE를 사용하도록 하자.. (그러나 FOR UPDATE는 phantom read의 위험이 있다. 반드시 읽은 레코드를 변경 할때만 사용 하도록 하자)
  * 잠금 읽기 기능 (LOCK IN SHARED, FOR UPDATE)는 COMMIT이나 ROLLBACK이 실행되면 해제됨, 하나의 트랜잭션에서만 유효하다.
  * 하나의 트랜잭션이 여러 번의 사용자 요청으로 완료되는 프로그램이라면 읽기 잠금을 사용해서는 안된다. (p.711)
  * 잠금 읽기는 반드시 트랜잭션 종료가 보장 되도록 작성하는것이 좋음

### INSERT, UPDATE, DELETE
  * INSERT, UPDATE, DELETE 쿼리는 기본적으로 쓰기 잠금을 사용함. (AUTO-COMMIT도 사실은 트랜잭션이 시작되고 종료 되는것)
  * InnoDB에서 UPDATE와 DELETE를 실행할때 SQL의 조건에 일치하는 레코드를 찾기 위해 참조 하는 모든 인덱스에 잠금을 건다.
    * MySQL은 쿼리에 사용된 조건 중에서 인덱스를 적절히 사용할 수 있는 조건만 스토리지 엔진으로 전달하기 때문.
  ```sql
    UPDATE employees
    SET last_name = '...'
    WHERE first_name='Gerogi' AND gender='F'
  ``` 
  * 위 쿼리에서 first_name에만 인덱스가 존재 한다면 first_name이 'Georgi'인 모든 레코드를 잠군다. (p.713)
  * UPDATE, DELETE 문장이 실행 될때는 항상 잠금 대상 레코드가 변경 대상 레코드보다 범위가 크거나 같다.
  * UPDATE나 DELETE 문자으이 조건으로 사용되는 칼럼이 있다면 그 칼럼에는 인덱스를 생성 하는것이 좋다. 
  * READ-COMMITED에서는 인덱스와 관꼐없이 실제 변경되는 레코드만 잠금을 걸게 된다.
    * 잠금을 걸었다가 나머지 조건에 일치하지 않아서 다시 잠금을 해제하는 방식
  * FOR UPDATE나 LOCK IN SHARE MODE도 동일한 방식으로 동작한다.

## SQL 문장별로 사용하는 잠금

### INSERT 쿼리의 잠금
  * 기본적으로 베타적(Exclusive) 레코드 잠금을 사용
  * 해당 테이블에 프라이머리 키나 유니크키가 존재한다면 중복 체크를 위해 공유 레코드 잠금을 먼저 획득
  * MySql에서는 추가적으로 인서트 인텐션 락을 사용
  * 

 