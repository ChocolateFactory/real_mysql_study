# 쿼리 종류별 잠금
## InnoDB의 기본 잠금

### SELECT 
  * REPETABLE-READ 이하의 트랜잭션 격리 수준에서 SELECT는 아무런 잠금을 사용하지 않는다.
  * SERIALIZABLE 격리 수준에서는 모든 SELECT 쿼리에 읽기잠금을 걸고 레코드를 읽는다.
  * 읽기 모드 잠금, 쓰기모드 잠금
    ```sql
    SELECT * FROM employess WHERE emp_no=1001 LOCK IN SHARE MODE;
    SELECT * FROM employees WHERE emp_no=1001 FOR UPDATE;
    ```
    * LOCK IN SHARE MODE는 읽기잠금만 걸기 떄문에 잠금을 획득한 트랜잭션에서 변경 하려면 쓰기 잠금을 또 획득 해야한다. ( 읽기 잠금을 획득한 상태에서 다시 쓰기 잠금을 획득하는것은 데드락을 유발함.)
    * 읽은 다음 변경 까지 해야한다면 처음 부터 FOR UPDATE를 사용하도록 하자.. (그러나 FOR UPDATE는 phantom read의 위험이 있다. 반드시 읽은 레코드를 변경 할때만 사용 하도록 하자)
  * 잠금 읽기 기능 (LOCK IN SHARED, FOR UPDATE)는 COMMIT이나 ROLLBACK이 실행되면 해제됨, 하나의 트랜잭션에서만 유효하다.
  * 하나의 트랜잭션이 여러 번의 사용자 요청으로 완료되는 프로그램이라면 읽기 잠금을 사용해서는 안된다. (p.711)
  * 잠금 읽기는 반드시 트랜잭션 종료가 보장 되도록 작성하는것이 좋음

### INSERT, UPDATE, DELETE
  * INSERT, UPDATE, DELETE 쿼리는 기본적으로 쓰기 잠금을 사용함. (AUTO-COMMIT도 사실은 트랜잭션이 시작되고 종료 되는것)
  * InnoDB에서 UPDATE와 DELETE를 실행할때 SQL의 조건에 일치하는 레코드를 찾기 위해 참조 하는 모든 인덱스에 잠금을 건다.
    * MySQL은 쿼리에 사용된 조건 중에서 인덱스를 적절히 사용할 수 있는 조건만 스토리지 엔진으로 전달하기 때문.
  ```sql
    UPDATE employees
    SET last_name = '...'
    WHERE first_name='Gerogi' AND gender='F'
  ``` 
  * 위 쿼리에서 first_name에만 인덱스가 존재 한다면 first_name이 'Georgi'인 모든 레코드를 잠군다. (p.713)
  * UPDATE, DELETE 문장이 실행 될때는 항상 잠금 대상 레코드가 변경 대상 레코드보다 범위가 크거나 같다.
  * UPDATE나 DELETE 문자으이 조건으로 사용되는 칼럼이 있다면 그 칼럼에는 인덱스를 생성 하는것이 좋다. 
  * READ-COMMITED에서는 인덱스와 관꼐없이 실제 변경되는 레코드만 잠금을 걸게 된다.
    * 잠금을 걸었다가 나머지 조건에 일치하지 않아서 다시 잠금을 해제하는 방식
  * FOR UPDATE나 LOCK IN SHARE MODE도 동일한 방식으로 동작한다.

## SQL 문장별로 사용하는 잠금

### INSERT 쿼리의 잠금
  * 기본적으로 베타적(Exclusive) 레코드 잠금을 사용
  * 해당 테이블에 프라이머리 키나 유니크키가 존재한다면 중복 체크를 위해 공유 레코드 잠금을 먼저 획득
  * MySql에서는 추가적으로 인서트 인텐션 락을 사용(p.717)
    * lock wait timeout 동안 기다리고 종료 시킨다.
  * INSERT INTO ... ON DUPLICATED KEY
    * INSERT 하려는 레코드에 키값이 이미 있는지 판단 하기 위해 공유 잠금을 걸어야 한다.
    * 레코드가 존재하면 베타적 잠금을 걸고 INSERT를 UPDATE를 실행, 존재하지 않으면 인텐션락을 걸고 INSERT
  * REPLACE ...
    * 중복된 키값이 이미 있는지 판단하기위해 공유잠금을 건다.
    * 그리고 중복된 레코드가 존재하면 베타적 잠금을 걸고 레코드를 삭제한다.
  * INSERT INTO table_new SELECT ... FROM table_old
    * 쿼리가 실행되는 동안 변경되지 않도록 보장 하기위해 table_old에는 공유 넥스트 키락을 설정한다.
    * INSERT 되는 레코드에 대해 배타적 레코드 락을 설정한다.
    * 데이터를 읽어오는 table_old의 값이 실행 도중 변경되면 master와 slave의 레코드 건수가 달라질 수도 있음.
    * 읽어오는 테이블의 공유잠금이 자주 문제가 된다. (다른 쿼리들의 실행을 방해함)
      * 피하는 법
        * 격리수준을 READ-COMMTED로 변경하고 innodb_lock_unsafe_binlog를 활성화
          * replication을 사용하는 서버에서는 사용하기 어려움.
        * 복제 방식을 Statment Based 에서 Record Based 로 변경
        * 두개 쿼리로 나누어서 실행한다.
          * SELECT INTO OUTFILE 으로 데이터를 파일로 저장하고, LOAD DATA INFILE에 적재.
          * DISK IO를 발생시킨다. 실시간으로 빈번하게 변경되는 테이블 이라면 제일 효과적..
    * REPLCAE INTO tb_new ... SELECT ... From tb_old
      * 읽어 오는 테이블에 공유잠금이 걸리고 tb_new엔 베타적 레코드 락이 걸린다.
  

 