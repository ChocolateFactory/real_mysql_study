# Mysql의 주요 처리 방식

성능에 미치는 영향이 큰 실행 계획과 관련된 단위 작업에 대해 보자.

### 테이블 풀 스캔

인덱스를 사용하지 않고 테이블 전체를 스캔

- 레코드수가 굉장히 적어서 인덱스보다 스캔이 더 빠른 경우(보통 페이지 1개로 구성된 경우)
- WHERE절이나 ON에 인덱스를 쓸 적절한 조건이 없는 경우
- Index range 스캔을 사용 가능하더라도 옵티마이저가 판단한 조건 일치 데이터가 너무 많은 경우
- max_seeks_for_key 변수를 특정 값으로 설정시에 cardi-nality나 선택도를 무시하고 최대 N건만 읽으면 된다고 판단한다.

### ORDER BY 처리(Using Filesort)

모든 정렬이 index를 거치지 않는 것은 아니지만 아래 조건에 의해서 보통 정렬 작업은 filesort를 이용하게 된다.

- 정렬기준이 너무 많아서 요건별 인덱스 생성이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT와 같은 처리의 결과를 정렬하는 경우
- UNION의 결과 같이 임시테이블의 결과를 정렬하는 경우
- 랜덤하게 결과 레코드를 가져와야하는 경우(16.1절에서 언급)

#### Sort Buffer

정렬을 위해 사용하는 별도 메모리 공간

정렬해야하는 레코드가 소트버퍼보다 크다면 디스크에 여러 조각으로 나눠 임시 저장후 다시 머지하는 과정(Multi merge)을 거친다 이때 Disk I/O가 수행된다. 

#### 정렬 알고리즘

##### 싱글 패스 알고리즘(5.0 이상)

소트 버퍼에 SELECT 되는 모든 칼럼을 담아서 정렬을 수행하는 방법

##### 투 패스 알고리즘(5.0 미만)

정렬 대상 칼럼과 PK만을 소트 버퍼에 담아 정렬 수행후 다시 PK로 테이블을 읽어서 데이터를 가져오는 알고리즘

5.0 이상에서도 특정조건이 되면 이방법을 사용한다.

- max_length_for_sort_data 파라미터로 설정된 값보다 클때
- BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때

####  정렬의 처리방식

일반적으로 아래로 내려갈수록 더 느린 방식이다.

- 인덱스 사용 정렬(별도 실행계획 코멘트 없음)
- 드라이빙 테이블만 정렬(Using filesort 표시)
- 조인 결과를 임시테이블로 저장 후 임시테이블에서 정렬(Using Temporary; Using filesort가 함께 표시)

나머지는 책 참고

#### 정렬 관련 상태변수

- Sort_merge_passes: 멀티 머지 처리 횟수
- Sort_range: index range full scan을 통해 검색된 결과에 대한 정렬 작업 횟수
- Sort_scan: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수.
- Sort_rows: 지금까지 정렬한 전체 레코드 수 

### GROUP BY 처리

GROUP BY에 사용된 HANING 조건절은 인덱스를 사용할 수 없으므로 튜닝을 원할때는 다른 방법을 사용해야한다.

#### 인덱스를 사용하는 GROUP BY(타이트 인덱스 스캔)

조인의 드라이빙 테이블에 속한 칼럼만을 이용해 그룹핑할때 해당 칼럼에 인덱스가 있다면 그 인덱스를 사용하여 그룹핑을 한다.

#### 루스 인덱스 스캔을 이용하는 GROUP BY

인덱스의 레코드를 건너 뛰면서 필요한 레코드만 가져오는 방식 

#### 임시테이블을 사용하는 GROUP BY

드라이빙 테이블이나 드리븐 테이블이나 인덱스를 전혀 사용하지 못할때 사용하는 방법

### DISTINCT 처리

집함 함수와 함께 사용되는지에 따라서 동작이 달라진다. 그리고 인덱스를 사용하지 못할때 항상 임시 테이블이 필요하지만 Using Temporary가 출력되지는 않는다.

#### SELECT DISTINCT ...

인덱스를 사용하면 정렬이 보장되지만 인덱스를 사용하지 않는 경우 정렬이 보장되지 않는다. 

사용상의 주의 사항으로는 DISTINCT가 함수가 아니므로 SELECT 하는 모든 컬럼 전체가 유니크한 레코드를 가져온다. 그래서 ()등으로 묶더라도 제거해버리고 사용한 컬럼 전체를 유니크하게 가져온다.

#### 집합함수와 함께 사용된 DISTINCT 

집합함수 내에서 사용된 DISTINCT는 집함함수의 인자로 전달된 칼럼 값이 유니크한 것들을 가져온다.

### 임시 테이블

Mysql 내부에서 사용되는(Using Temporary) 임시 테이블

처음에는 메모리에 생성됐다가 테이블이 커지면 디스크로 옮겨진다(예외 케이스에는 바로 디스크에 생성되기도 한다)

 사용자가 생성한 CRTEATE TEMPORARY TABLE과 달리 쿼리의 처리가 완료되면 저동을 삭제된다.

#### 임시 테이블이 필요한 쿼리

- ORDER BY와 GROUP BY가 서로 다른 컬럼에 걸려있을때
- ORDER BY나 GROUP BY가 조인 순서상 첫번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 존재하는 경우(혹은 DISTINCT가 인덱스로 처리 불가능한 경우)
- UNION이나 UNION DISTINCT가 사용된 select_type 칼럼이 UNION RESULT인 경우
- UNION ALL이 사용된 쿼리
- 실행 계획에서 select_type이 DERIVED인 경우

#### 임시 테이블이 디스크에 생성되는 경우(MyISAM 엔진 사용)

- 저장해야하는 내용중 BLOB나 TEXT등 대용량 칼럼이 있는 경우
- 레코드의 전체 크기나 UNION이나 UNION ALL에서 SELECT 되는 칼럼중 512바이트 이상의 크기인 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 칼럼이 있는 경우
- 저장할 데이터 전체 크기가 tmp_table_size 또는 max_heap_table_size 시스템 설정보다 큰 경우

#### 임시테이블 관련 상태 변수

Created_tmp_tables: 쿼리 처리를 위해 생성된 임시테이블의 갯수를 누적하는 값

Created_tmp_disk_tables: 디스크에 만들어진 임시테이블의 갯수만 누적하는 값

#### 주의사항

disk에 임시테이블이 생성되는 경우 성능상 이슈가 될 수 있다.



### 테이블 조인

INNER JOIN은 어느 테이블을 먼저 읽어도 결과가 달라지지 않으므로 옵티마이저가 순서를 조절해 최적화 할 수 있다. MySQL에서 조인은 Nested-loop라는 중첩 루프 형태만 지원한다.

## 조인의 종류

### INNER JOIN 

Nested Loop(2중 for loop) 방식만 지원

### OUTER JOIN

Nested Loop(2중 for loop)를 사용해서 드리븐 테이블의 결과가 없는 경우 NULL로 가져옴

LEFT OUTER JOIN을 쓸때 주의해야할점

- 레코드가 없을 수도 있는 쪽의 테이블의 조건을 ON절에 명시하지 않으면 옵티마이저가 INNER JOIN으로 처리할 가능성이 있다.

### FULL OUTER JOIN

MySQL에서 기본 지원하지는 않지만 INNER JOIN과 OUTER JOIN을 활용하면 같은 기능을 구현 가능하다.

이건 451 페이지에서 직접적으로 언급된다.

### 카테시안 조인(FULL JOIN, CROSS JOIN)

모든 테이블의 2개 테이블의 모든 레코드 조합 결과를 가져온다. N x M 의 레코드를 가져오므로 굉장히 무겁다. 

MySQL에서는 INNER JOIN과 카테시안 조인이 문법적으로 구분되지 않고 적절한 조건이 있으면 INNER JOIN 없으면 카테시안 조인으로 처리된다.

### NATURAL JOIN 

INNER JOIN을 명시하는 여러가지 방법중 하나이다. 

```sql
FROM e, s WHERE e.no = s.no

FROM e INNER JOIN s ON e.no = s.no

FROM e INNER JOIN s Using (no);
```

하지만 가능하면 사용하지 않는게 좋다. 테이블의 컬럼명이 변경된다던지 하는 문제를 놓치기 쉬워지고 유지보수 비용을 높이는 역효과만 가져올 것이다.

### Single-sweep multi join

중첩하는 테이블의 갯수만큼 루프가 중첩되는 것을 말한다. 

### 조인 버퍼 

MySQL에서는 드리븐 테이블의 인덱스를 활용할 수 없는 등의 테이블 풀 스캔이 필요한 경우 드라이빙 테이블의 레코드를 메모리에 캐시하고 이 캐시를 조인하는 형태로 처리한다. 



## 조인 관련 주의사항

#### 조인 실행 결과와 정렬 순서

일반적으로는 드라이빙 테이블의 레코드를 읽는 순사거 전체 쿼리 결과 순서에 적용된다. 하지만 이는 옵티마이저가 예상과 다른 선택을 했을때 등의 상황에 따라 달라 질 수 있다.  그러니 ORDER BY 절을 활용해서 언제나 정렬을 보장하는게 좋다. 그리고 ORDER BY를 사용했다고 언제나 정렬작업을 수행하는 것도 아니고 쿼리 결과가 정렬된 상태로 반환되면 그대로 반환한다.

#### INNER JOIN VS OUTER JOIN 

두 조인의 성능을 물어봤을때 OUTER JOIN이 더 많은 레코드를 가져오므로 성능이 느릴 것이라 생각하기 쉽지만 사실 두 조인의 비교 횟수등이 같기에 성능은 거의 같다. 