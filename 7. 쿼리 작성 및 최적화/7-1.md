# 쿼리 작성및 최적화
* Query의 패턴별로 어떻게 처리 되는가?

## 쿼리와 연관된 시스템 설정(p.378)

### SQL Mode(p.378)
	* SQL이 어떤 SQL syntax를 지원하고 있는지 그리고 데이터의 validation을 검사하는 수준과 방법은 어떤것들인지를 나타내는것
	* 대표적인 설정값(P.378)
		*  STRICT_ALL_TALBES … etc

### 대,소문자의 구분
	* 테이블이 디스크의 디렉토리나 파일로 매핑되기 때문에 운영체제에 따라 대소문자의 구분여부가 결정된다.
	* 윈도우에 설치되면 대소문자를 구분하지 않지만 유닉스 계열의 운영체제에서는 대소문자를 구분한다.
	  
### 리터럴(literal) 표기법
	* Boolean
		* BOOL 이나 BOOLEAN 같은 타입이 있지만 사실은 TINYINT 타입에 대한 동이어일 뿐이다. ( 실제로 테이블을 BOOL로 생성후에 칼럼 타입을 조회해보면 TINYINT 임)
		* MySQL에선 FALSE가 0을 의미 TRUE는 1만을 의미한다. (ex> P.385)
		
### MySQL 연산자
	* MySQL은 `<=>` 와 같은 null-safe한 연산자를 제공함 (P.385)
	* `<>`는 not-equal
	* `||` (or 연산자) 는 SQL Mode에 따라 concat의 기능으로 사용될 수 있음. `||` 와 `&&` 의 사용은 자제하는게 가독성에 도움이 될것이다.
	* LIKE 연산자는 `%, _` 와같은 와일드 카드 문자가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔을 사용 할 수있지만 검색어의 앞쪽에 있으면 인덱스 레인지 스캔을 사용하지 못한다. ( 인덱스의 left-most 특성)
	* BETWEEN 과 IN
		* BETWEEN은 크다, 작다 비교연산을 묶어둔것, IN은 여러개의 동등비교(=) 연산을 묶어둔것
		* BETWEEN은 선형으로 인덱스를 검색해야함, IN은 동등비교를 여러번 수행하는 것과 같은 효과 (P.394)
		* IN 연산자의 비교값이 상수가 아닌경우는 상당히 느려질 수 있음. (P.397)
		* NOT-IN은 부정형 비교이어서 처리 범위를 줄이는 조건으로는 사용 할 수 없기때문에 인덱스 풀 스캔을 한다.

### 내장 함수
	* NOW, SYSDATE
		* NOW는 쿼리가 실행되는 시점에 값을 할당 받아서 쿼리의 모든 부분에 같은 값을 사용하게 되지만 SYSDATE는 함수가 호출되는 시점에 값을 받아온다.
		* 이때문에 SYSDATE가 사용된 구문은 slave에서 안정적으로 복제가 되지 못함.
		* SYSDATE는 꼭 써야할 상황이 아니라면 피하는게 ㅎㅎ;
	* GROUP_CONCAT
		* 지정한 칼럼들의 값을 연결하기위해 제한적인 메모리 버퍼 공간을 사용한다
		* 기본값이 1KB 이기때문에 group_concat을 자주 사용한다면 이 설정값을 늘려주는게 좋음.
	* INET_ATON, INET_NATON
	* COUNT
		* count의 인자 `*`은 레코드 자체를 의미한다. 모든 칼럼을 읽는 형태로 처리하지는 않는다.
		* count 만을 가져오는 쿼리라면 orderby 나 left join같은 의미없는것들은 지우도록 하자.
		* Count(column1) 이라고 사용하면 column1이 null이 아닌 건수를 가져오므로 nullable한 컬럼에 대해서는 주의하자

## SELECT
### 처리 순서 (P.420)OR연산의 경우 읽어와야할 레코드가 훨 늘어나기때문에
### 인덱스를 사용하기 위한 기본 규칙 (p.422)
	* 인덱스된 칼럼의 값을 변환하지 않고 그대로 사용해야 한다.
		* 인덱스는 칼럼의 값을 아무런 변환없이 저장함.
	* WHERE 절에 사용되는 비교대상의 값은 데이터 타입이 일치해야한다.
		* 데이터 타입이 다르면 데이터를 옵티마이저가 좀 더 처리하기 효율적인 타입으로 형변환을 하기 때문에 인덱스 레인지 스캔을 사용하지 못하고 인덱스 풀 스캔을 사용하게 된다.

### WHERE의 INDEX 사용 (p.424)
	* 각 조건들이 명시된 순서보다는 인덱스가 걸린 칼럼에대한 조건이 있는지 없는지가 중요.
	* OR 연산자를 사용을 조심해야한다.
		* OR연산에 사용된 인자들이 인덱스가 없는 인자가 포함되어있다면. 풀 테이블 스캔을 할 수 밖에 없고
		* 각 인자들의 인덱스가 존재 한다고해도, index_merge방식으로 실행을 하게된다. 이는 제대로된 인덱스하나를 레인지 스캔하는것 보다는 느리기때문에

### GROUP BY의 INDEX 사용(P.426)
	* group by 절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야한다.
	* 인덱스를 구성하는 칼럼중에서 뒷쪽에 있는 칼럼은 group by절에 명시되어있지 않아도 인덱스를 사용할 수 있지만 앞쪽에 있는 칼럼이 group by절에 명시 되지않으면 인덱스를 사용 할 수 없다.
	* group by절에 명시된 칼럼이 하나라도 인덱스에 없으면 인덱스를 이용하지 못한다.

### ORDER BY의 INDEX 사용(P.426)
	* group by와 비슷 하지만 오름차순및 내림차순 옵션이 인덱스와 같거나 또는 정반대의 경우에만 사용가능
	* Mysql의 인덱스는 모두 오름차순 정렬이어서 order by절의 모든 칼럼이 오름차순이나 내림 차순일때만 가능.

### WHERE 조건과 ORDER BY(OR GROUP BY) 절의 인덱스 사용 (p.428)
	* 일반적으로 where과 group by 혹은 order by는 같이 사용하게됨.
	* where 절의 비교조건에서 사용하는 칼럼과 정렬 대상칼럼이 모두 하나의 인덱스에 연속해서 포함 되어있을 경우에 where 과 order by절이 같은 인덱스를 사용할 수 있음
	* where 절만 인덱스 사용이 가능한 경우 별도의 정렬 과정 (filesort)를 거쳐서 정렬을 수행 where절의 조건에 일치하는 레코드가 많지 않을때 효율적인 방식
	* order_by절만 인덱스를 이용하는 경우, order_by절의 순서대로 인덱스를 읽으면서 레코드 한건씩을 where의 조건에 일치하는지 비교함. 아주많은 레코드를 조회해서 정렬할때 이런식으로 튜닝 하기도함.
	* where절에서 equal 조건으로 비교된 칼럼과 order_by 절에 명시된 칼럼의 순서가 인덱스 칼럼의 왼쪽부터 일치해야한다. (p.430)
	* where 과 group by의 조합도 같은 기준이 적용된다.
	
### Group by 절과 order by 절의 인덱스 사용
	* 인덱스를 사용하려면 group by절에 명시된 칼럼과 order by에 명시된 칼럼의 순서와 내용이 모두 같아야 하낟.
	* MySQL의 group by는 칼럼에 대한 정렬까지 함께 수행하는것이 기본 작동방식이어서 group by와 order by 칼럼의 내용과 순서가 같다면 order by를 생략해도 무방함.

### Where절의 비교조건 사용시 주의 사항(p.433)
	* NULL 비교
		* MySQL에서는 NULL값이 포함된 레코드도 인덱스로 관리됨.
		* SQL 표준에서  NULL은 비교 될 수 없는 값임. 그래서 한쪽이라도 NULL 이면 결과도 NULL임.
		* NULL비교를 할때는 가급적 IS NULL 연산자를 사용하자
	* 문자열 숫자 비교
		* 문자열이나 숫자 칼럼을 비교할때는 반드시 그 타입에 맞추어 상수를 사용할것
	
### 날짜 비교 (p.435)
	* DATE나 DATETIME의 값과 문자열을 비교할때는 문자열 값을 자동으로 DATETIME타입의 값으로 변환을 해서 비굘르 수행함. 문자열을 명시적으로 변환해줄 필요는 없다.
	* 칼럼을 변형해 비교하지 말고 상수를 변경하는 형태로 조건을 사용하는것이 좋음
	* TIME_STAMP의 경우는 비교값으로 사용되는 상수 리터럴을 비교 대상 칼럼의 타입에 맞게 변환해서 사용하는것이 좋음.
	
### DISTINCT (p.438)
	* group by와 비슷하게 처리되나 distinct는 정렬을 보장하지 않음.
	* SELECT DISTINCT …는 SELECT 되는 레코드를 유니크하게 처리하는것이지, 칼럼을 유니크하게 처리하는것이 아니다.
	* 칼럼만 유니크하게 조회하는 방법은 없음.
	* 집함 함수와 사용된 distinct는 임시테이블을 만들어 낸다. 인덱스된 칼럼에 대한 distinct는 인덱스를 활용해 처리할 수있음.

### LIMIT
	* LIMIT에서 필요한 레코드 건수만 준비되면 쿼리를 종료 시킨다.
	* 정렬이나 grouping 또는 distinct가 없는 쿼리에서 limit을 사용하면 상당히 빨리 끝날 수 있다.
	
### JOIN
	* 드리븐 테이블에서는 인덱스 탐색 작업과 스캔작업을 드라이빙 테이블에서 읽은 레코드 수만큼 반복함.

























