# 쿼리 작성및 최적화
* Query의 패턴별로 어떻게 처리 되는가?

## 쿼리와 연관된 시스템 설정

### SQL Mode
	* SQL이 어떤 SQL syntax를 지원하고 있는지 그리고 데이터의 validation을 검사하는 수준과 방법은 어떤것들인지를 나타내는것
	* 대표적인 설정값(P.378)
		*  STRICT_ALL_TALBES … etc

### 대,소문자의 구분
	* 테이블이 디스크의 디렉토리나 파일로 매핑되기 때문에 운영체제에 따라 대소문자의 구분여부가 결정된다.
	* 윈도우에 설치되면 대소문자를 구분하지 않지만 유닉스 계열의 운영체제에서는 대소문자를 구분한다.
	  
### 리터럴(literal) 표기법
	* Boolean
		* BOOL 이나 BOOLEAN 같은 타입이 있지만 사실은 TINYINT 타입에 대한 동이어일 뿐이다. ( 실제로 테이블을 BOOL로 생성후에 칼럼 타입을 조회해보면 TINYINT 임)
		* MySQL에선 FALSE가 0을 의미 TRUE는 1만을 의미한다. (ex> P.385)
		
### MySQL 연산자
	* MySQL은 `<=>` 와 같은 null-safe한 연산자를 제공함 (P.385)
	* `||` (or 연산자) 는 SQL Mode에 따라 concat의 기능으로 사용될 수 있음. `||` 와 `&&` 의 사용은 자제하는게 가독성에 도움이 될것이다.
	* LIKE 연산자는 `%, _` 와같은 와일드 카드 문자가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔을 사용 할 수있지만 검색어의 앞쪽에 있으면 인덱스 레인지 스캔을 사용하지 못한다. ( 인덱스의 left-most 특성)
	* BETWEEN 과 IN
		* BETWEEN은 크다, 작다 비교연산을 묶어둔것, IN은 여러개의 동등비교(=) 연산을 묶어둔것
		* BETWEEN은 선형으로 인덱스를 검색해야함, IN은 동등비교를 여러번 수행하는 것과 같은 효과 (P.394)
		* IN 연산자의 비교값이 상수가 아닌경우는 상당히 느려질 수 있음. (P.397)
		* NOT-IN은 부정형 비교이어서 처리 범위를 줄이는 조건으로는 사용 할 수 없기때문에 인덱스 풀 스캔을 한다.

### 내장 함수
	* NOW, SYSDATE
		* NOW는 쿼리가 실행되는 시점에 값을 할당 받아서 쿼리의 모든 부분에 같은 값을 사용하게 되지만 SYSDATE는 함수가 호출되는 시점에 값을 받아온다.
		* 이때문에 SYSDATE가 사용된 구문은 slave에서 안정적으로 복제가 되지 못함.
		* SYSDATE는 꼭 써야할 상황이 아니라면 피하는게 ㅎㅎ;
	* GROUP_CONCAT
		* 지정한 칼럼들의 값을 연결하기위해 제한적인 메모리 버퍼 공간을 사용한다
		* 기본값이 1KB 이기때문에 group_concat을 자주 사용한다면 이 설정값을 늘려주는게 좋음.
	* INET_ATON, INET_NATON
	* COUNT
		* count의 인자 `*`은 레코드 자체를 의미한다. 모든 칼럼을 읽는 형태로 처리하지는 않는다.
		* count 만을 가져오는 쿼리라면 orderby 나 left join같은 의미없는것들은 지우도록 하자.
		* Count(column1) 이라고 사용하면 column1이 null이 아닌 건수를 가져오므로 nullable한 컬럼에 대해서는 주의하자

## SELECT
### 처리 순서 (P.420)OR연산의 경우 읽어와야할 레코드가 훨 늘어나기때문에
### 인덱스를 사용하기 위한 기본 규칙 (p.422)
	* 인덱스된 칼럼의 값을 변환하지 않고 그대로 사용해야 한다.
		* 인덱스는 칼럼의 값을 아무런 변환없이 저장함.
	* WHERE 절에 사용되는 비교대상의 값은 데이터 타입이 일치해야한다.
		* 데이터 타입이 다르면 데이터를 옵티마이저가 좀 더 처리하기 효율적인 타입으로 형변환을 하기 때문에 인덱스 레인지 스캔을 사용하지 못하고 인덱스 풀 스캔을 사용하게 된다.

### WHERE의 INDEX 사용 (p.424)
	* 각 조건들이 명시된 순서보다는 인덱스가 걸린 칼럼에대한 조건이 있는지 없는지가 중요.
	* OR 연산자를 사용을 조심해야한다.
		* OR연산에 사용된 인자들이 인덱스가 없는 인자가 포함되어있다면. 풀 테이블 스캔을 할 수 밖에 없고
		* 각 인자들의 인덱스가 존재 한다고해도, index_merge방식으로 실행을 하게된다. 이는 제대로된 인덱스하나를 레인지 스캔하는것 보다는 느리기때문에

### GROUP BY의 INDEX 사용(P.426)
	* group by 절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야한다.
	* 인덱스를 구성하는 칼럼중에서 뒷쪽에 있는 칼럼은 group by절에 명시되어있지 않아도 인덱스를 사용할 수 있지만 앞쪽에 있는 칼럼이 group by절에 명시 되지않으면 인덱스를 사용 할 수 없다.
	* group by절에 명시된 칼럼이 하나라도 인덱스에 없으면 인덱스를 이용하지 못한다.

### ORDER BY의 INDEX 사용(P.426)
	* group by와 비슷 하지만 오름차순및 내림차순 옵션이 인덱스와 같거나 또는 정반대의 경우에만 사용가능
	* Mysql의 인덱스는 모두 오름차순 정렬이어서 order by절의 모든 칼럼이 오름차순이나 내림 차순일때만 가능.




















